---
title: "Assignment"
author: "Nguyen Hoang Nhat Linh"
date: "2025-11-23"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(knitr)
library(ggplot2) # this is primarly used to better visualise the visualisations
```

# Load Data

First of all, we begin by reading the datasets from its respective CSV files. Afterwards, we inspect on each datasets to see the total rows and columns. This allow us to know the original dataset characteristics.

```{r}
# Read csv files with the directory well set beforehand
engine <- read.csv("Engine.csv")
auto <- read.csv("Automobile.csv")
maint <- read.csv("Maintenance.csv")

# Inspect 'Engine'' data
print("Engines:")
str(engine)
summary(engine)
```

```{r}
# Inspect 'Automobile' data
print("Automobile:")
str(auto)
summary(auto)
```

```{r}
# Inspect 'Maintenance' data
print("Maintenance:")
str(maint)
summary(maint)
```

Using "str()", the overall structure of each datasets are well displayed.From the summaries above, we can see that the dataset overview can be seen as follow:

- **Engine**: 8 variables with 88 rows
- **Automobile**: 13 variables with 204 rows
- **Maintenance**: 7 variables with 374 rows 

This is the overall structure when run the datasets in R. From here, we would proceed to solve each tasks.


# Task 1:  

## 1.1: Write the code to inspect the data structure and present the data: The missing values in the dataset were written as "?", replace any "?" with NA; Write code to check: after replacing, how many rows were affected in total? Does this change alter the data distribution?

### Count "?" and replace it with "NA"

In R, the question mark **'?'** is not recognize by as a missing value. This could cause errors in statistical analysis. Therefore, by replacing **'?' to 'NA'** we can code to find out the missing values.

In this question, using the *"mutate()"* function with *"(across(where(is.character)))"*,we can scan all character columns and replace all the '?' to 'NA'.

```{r}
# Count "?" and replace it with "NA"
NA_replace <- function(df, name) {
  # Count rows with "?"
  rows_with_q <- df %>% 
    filter(if_any(everything(), ~ . == "?")) %>% 
    # counts total number of rows that contain at least one instance '?' (everything)
    nrow()
  
  # Replace "?" with NA
  df_clean <- df %>%
    mutate(across(where(is.character), ~na_if(., "?"))) 
  # scan all character columns and replace all the '?' to 'NA'
  
  print(paste("Number of rows affected in", name, ":", rows_with_q))
  return(df_clean)
}

# Apply cleaning
engines <- NA_replace(engine, "Engines")
autos <- NA_replace(auto, "Automobiles")
maint <- NA_replace(maint, "Maintenance")
```

In total, there are 6 rows being affected (all in 'Engine').

```{r}
# Total NA
print(paste("Total NAs in Engine:", sum(is.na(engines))))
print(paste("Total NAs in Automobile:", sum(is.na(autos))))
print(paste("Total NAs in Engine:", sum(is.na(maint))))
```

As we can see, there are 6 '?' and when we replace it, we end up with **34 NAs in total**.

Here, when we convert it to NA, we are simply marking the missing spots properly so R can handle them. All the real numbers and categories stays exactly the same, so the overall distribution of the dataset does not change.

## 1.2 Convert categorical variables BodyStyles, FuelTypes, ErrorCodes to factors
```{r}
# Convert categorical variables to factors

# Converting 'BodyStyles' from character to factor
autos$BodyStyles <- as.factor(autos$BodyStyles) 

# Converting 'FuelTypes' from character to factor
engines$FuelTypes <- as.factor(engines$FuelTypes) 

# Converting 'ErrorCodes' from character to factor
maint$ErrorCodes <- as.factor(maint$ErrorCodes) 
```

By using **"as.factor"** we transform the 'BodyStyles', 'FuelTypes', and 'ErrorCodes' from characters types to factors. This is to ensure the that variables are recognised as a factor rather than numbers or simple text. This way, R can read them correctly to group data when plotting and analysing.

## 1.3 Replace the missing values in column Horsepower with the median horsepower
```{r}
# Convert Horsepower to numeric
engines$Horsepower <- as.numeric(engines$Horsepower)

# This is just an extra step to make sure it is also numeric
engines$EngineSize <- as.numeric(engines$EngineSize)

# since the Horsepower column is numeric
hp_median <- median(engines$Horsepower, na.rm = TRUE)

# Replace NA with the median
engines <- engines %>%
  mutate(Horsepower = ifelse(is.na(Horsepower), hp_median, Horsepower)) 
# checks every row in the Horsepower column.
# If a value is missing "(is.na())", it replaces it with the calculated 'hp_median'
# otherwise it keeps the original value

print(paste("Missing Horsepower values remaining:", sum(is.na(engines$Horsepower))))
```

In this situation, 'Horsepower' is converted to numeric so calculations work. Then, imputing the missing values in 'Horsepower' column with **median** would offer a better better than using mean. As median is less sensitive to outliers than mean, making it a better option to chose considering the central tendency of this variable. 

Additionally, **"mutate()"** and **"ifelse()"** were used to select only the NAs to replace with the calculated "hp_median" above. This would eventually preserves the integrity of the existing data.

## 1.4 Select the appropriate chart type and display: horsepower distribution

```{r}
# Histogram for distribution 
ggplot(engines, aes(x = Horsepower)) +
  geom_histogram( # this creates a histogram
    binwidth = 10, fill = "skyblue", color = "black") +
  geom_vline(aes(xintercept = median(Horsepower)), color="red", linetype="dashed") +
  # the line above creates an abline that shows the median for 'Horsepower'
  labs(title = "Distribution of Engine Horsepower", # this is the name for the histogram
       subtitle = paste("Median Horsepower =", hp_median), # this adds a sub-title
       x = "Horsepower", y = "Count") + # names the x and y axis
  theme_minimal() # removes the default gray background
```
As the variable 'Horsepower' is a numeric variable, its distribution can be visualized using a histogram. The abline (red line) shows where the middle value is. This makes the shape and central tendency of horsepower becomes much easier to understand. Our red line here shows that the median horsepower is around 102.

# Task 2: 

## 2.1 The code to analyse the distribution of the horsepower across the engine types.

Here, we would want to see the 'Horsepower' (a numeric variable) and we would want to see it across engine categories (in our case is Engine Types).

A boxplot would show the median, this helps us to quickly identify patterns, such as which engine types are generally more powerful or more consistent in their performance. Most importantly, it shows the overall spread of horsepower values, and any extreme points that stand out as outliers. 

Therefore, employing a box plot would allow us to have a clearer understanding of how horsepower is distributed across the different engine designs.

```{r}
# To use boxplots to analyse the distribution and 
# compare continuous variable (in our case, horsepower) across multiple categories.

ggplot(engines, aes(x = EngineType, y = Horsepower, fill = EngineType)) + # this defines the x and y
  geom_boxplot() + # this creates a box plot
  labs(title = "Horsepower Distribution by Engine Type", # title for the box plot
       x = "Engine Type", y = "Horsepower") + # this names the x and y axis
  theme_minimal() + # removes the default gray background
  # the one below rotates the labels 45 degrees to prevent overlapping
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

From the boxplot above, we can see that two 'dohc' (red) and 'ohcv' (blue) generally produces a higher median horsepower compared to other types. However, the 'ohc' (green) shows a great range of horsepower.
 
We can easily spot several outliers that indicates an "irregular" in what is generally shown. For instance, while most 'ohc' (pink) engines are low-power, some specific models have much higher output.

# 2.2 Write the code to investigate the distribution of the horsepower across the groups of the engine sizes (e.g., 60-90, 91-190, 191-299, 300+). Henceforth, visualise the findings.

To know the distribution of horsepower across groups of engines sizes, we will need to create bins that represent each groups (60-90, 91-190, 191-299, 300+). Here, we know that 'EngineSize' is a continuous variable. 

To create bins, the function **"mutate()"** was used to create a new column 'SizeGroup' and **"cut()"** was used to categorize rows base on their 'EngineSize' variable.

```{r}
# Create bins: 60-90, 91-190, 191-299, 300+
engines <- engines %>%
  mutate(SizeGroup # create a new column 'SizeGroup'
         = cut(EngineSize, # categorize rows base on their 'EngineSize'
                         breaks = c(59, 90, 190, 299, Inf), 
                         labels = c("60-90", "91-190", "191-299", "300+")))


# Visualisations
ggplot(engines, aes(x = Horsepower, fill = SizeGroup)) + # defines the x and y axis
  geom_histogram( # Creates a histogram
    binwidth = 15, color = "black", alpha = 0.7) + 
  # groups horsepower into bins 15 units wide, black colored with 0.7 opacity
  facet_wrap(~SizeGroup, scales = "free_y") + 
  # splits the single chart into separate mini-charts for each 'SizeGroup'
  labs(title = "Horsepower Distribution by Engine Size Group", # chart's title
       x = "Horsepower", y = "Frequency") +  # this names the x and y axis
  theme_minimal() # removes the default gray background

```

We generally expect a positive correlation such as larger engine size groups (300+), should correlate with the higher horsepower ranges in the histogram.

Here, the histogram confirms it. We can see a positive correlation between engine sizes and horsepower as follow:

- **Small engines (60-90)** and **(91-190)**: Strictly concentrated at the lower end of the horsepower scale.

- **Medium engines (191-299)**: Interestingly, while most fall in the average range, some outliers does shows the highest horsepower.

- **Large engines (300+)**: Here, it is reasonable when large engines fall mostly in high horsepower ranges. However, the distribution only falls in 2 specific level of horsepower.

As we can observe, most of the times the larger the engines the horsepower would be higher as well. However, some outliers (special cases) would offer a different horsepower outcome. This also means that, not all engine size larger than 300+ would bring back the best 'Horsepower' range.


# Task 3:

## Clean data (eliminates duplications)

Before we perform the analysis, it is important to ensure that the 'Engine' dataset does not contain duplicate. Since if duplicates exist in the engines table, merging it with the autos table would result in a "many-to-many" join.

```{r}
# Clean data
print("Duplicate Engine Models found (original Engine data):")
duplicate_engines <- engines %>% # taking the 'engines' data frame
  group_by(EngineModel) %>% # creating groups for every unique value in 'EngineModel'
  filter(n() > 1) # counts the number of rows in the current group, count groups greater than 1
print(duplicate_engines)

```

As we can see here, these are the duplicates within engine.


```{r}
# Create a unique version to merge reliably (without duplicates)
engines_unique <- engines %>%
  distinct(EngineModel, .keep_all = TRUE) # ensure each engine model appears only once

# Merge only Automobile and unique Engine data
car_engine_merged <- inner_join(autos, engines_unique, by = "EngineModel") 
#combine 'Automobile' (Mpg) and 'engines_unique data' (FuelTypes)
```

By applying distinct **"(EngineModel, .keep_all = TRUE)"**, we can ensure that each engine model appears only once, guaranteeing a clean one-to-one relationship when joining with the autos dataset.

We then use **"inner_join"** to combine the 'Automobile' data (for MPG) and the  'engines_unique data' (for FuelTypes), creating the normalized dataset, where each car has one unique set of engine specifications (this is essential for statistical testing).

## 3.1 Do diesel cars have higher average CityMpg than gasoline cars? Provide statistical evidence

To compare the fuel efficiency of diesel and gasoline cars, a two-Sample t-test was performed. This statistical test would allow us to compare how the mean in 'CityMPG' differs between two independent groups (diesel vs. gas).

Here, 'CityMpg' would act as a measurement to compare these two.

```{r}
# T-test to compare the means of CityMpg and FuelTypes (Gas & Diesel).
print("--- T-Test: Diesel vs Gas CityMpg ---") # the title
t_test_result <- t.test(CityMpg ~ FuelTypes, data = car_engine_merged) # employing t-test
print(t_test_result)
```

In our t-test, we can see that it showed a p-value of **0.0014**, which is far below the standard significance threshold of 0.05 ($\alpha$). This indicates strong statistical evidence that the average 'CityMpg' is different between diesel and gasoline cars.

More importantly, the mean in group shows that diesel average **30.3 MPG**, while gas averaged **24.68 MPG**. This means that diesel cars have a higher mean and we can say that diesel cars really do bring back better fuel efficiency than gasoline.

### Visualisation

```{r}
# Visualization
ggplot(car_engine_merged, aes(x = FuelTypes, y = CityMpg, fill = FuelTypes)) +
  geom_boxplot() + # this creates a box plot
  labs(title = "City MPG Distribution by Fuel Type", # the title
       y = "City Miles Per Gallon (MPG)",  # names the y axis
       x = "Fuel Type") +  # names the x axis
  theme_minimal() # removes the default gray background
```

To better see the differences, a boxplot displaying these 2 numeric variables. Here, we can see that diesel cars have a highe median 'CityMpg', and the majority distribution sits above gasoline's.

## 3.2  How does DriveWheels affect fuel efficiency (CityMpg and HighwayMpg)?

To understand how the vehicle's drive configuration influences fuel efficiency, MPG values were grouped. In this problem, **"group_by()?**" and **"summarise()"** were used for both 'CityMpg' and HighwayMpg to compute indicators of efficiency for each type.

In short, the **"group_by()"** will separate the data by drive type and the **"summarise()"** will compute the mean Mpg for each group ('CityMpg' and 'HighwayMpg'). This would allow direct comparison of fuel efficiency across different types of drive.

```{r}
# Group by DriveWheels and calculate mean MPG metrics to quantify the relationship.
efficiency_summary <- car_engine_merged %>%
  group_by(DriveWheels) %>% # separates the data by drive type
  summarise( # compute the mean Mpg for each group
   gitAvg_CityMpg = mean(CityMpg, na.rm = TRUE), # mean of CityMpg
    Avg_HwyMpg = mean(HighwayMpg, na.rm = TRUE) # mean of HighwayMpg
  )

print("Average City and Highway MPG by Drive Wheels:")
print(efficiency_summary)
```

From the table above, we can see the following trends:

- **4wd** vehicles (at 27.22) shows lower Mpg than Fwd vehicles , and slightly higher than Rwd. Even so, it is still reasonable to say that 4wd systems does add significant weight and require more engine output to move both axles.

- **Fwd** vehicles (34.23) has the highest Mpg in both city and highway conditions. Here, we can see that Fwd vehicles offer a much more fuel-efficient type of vehicle.

- **Rwd** vehicles, on the other hand, shows lowest fuel efficiency (at 25.64).This indicates that regardless, Rwd would be the type of vehicles that cost energy the most.

### Visualisation

To put this comparison into better visualisation, we can use boxplot to see the entire distribution of 'CityMpg' across the three ordered 'DriveWheels' groups.

```{r}
# For CityMpg
ggplot(car_engine_merged, aes(x = DriveWheels, y = CityMpg, fill = DriveWheels)) +
  geom_boxplot() +  # This creates a box plot
  labs(title = "Impact of Drive Wheels on City MPG",
       y = "City Miles Per Gallon (MPG)",
       x = "Drive Wheels") +
  theme_minimal() # removes the default gray background
```

The boxplot shows the exact trends the were found previously. Fwd vehicles show the highest median and widest overall distribution, indicating a diverse set of fuel-efficient models.

In contrast, Rwd and 4wd vehicles cluster toward lower MPG values. The visualization makes it evident that Drive Wheels plays an important role in vehicle efficiency.

## 3.3  Filter out those engines in the dataset that have trouble or are suspected of having trouble

To focus specifically on vehicles with mechanical issues, the Maintenance dataset was filtered to include only records with **ErrorCodes $\neq$ 0**. 

First of all,  we filer as it is important as it allows us to analyze only vehicles that genuinely exhibit issues. As a code = 0 means “No error,” while negative or positive values indicate faults or suspected problems.

```{r}
# Merge all three tables and filter out 'No error' records (ErrorCodes != "0") 
# to focus solely on vehicles confirmed or suspected of having a failure.

full_data <- maint %>%
  filter(ErrorCodes != "0") %>% # filters to keep rows where ErrorCodes is not equal "0"
  inner_join(autos, by = "PlateNumber")%>% 
  # merges filtered 'maint' with 'autos' based on the matching vehicle 'PlateNumber' 
  # to link the trouble records to specific vehicles
  inner_join(engines_unique, by = "EngineModel") 
# merges the resulting data with 'engines_unique' base on 'EngineModel'
```

Using **"(filter(ErrorCodes != "0"))"**, we exclude the records that are classified as **"No error"** (0).

After filtering, the 'Maintenance' records were joined with the 'Automobile' and 'Engine' datasets using inner joins. By using inner join, we ensure that only vehicles that appear in all three datasets are included, creating a clean dataset that represents only problematic vehicles.

## 3.4 Top 5 common troubles are related to

Here, the resulting **"full_data"** contains only confirmed or suspected trouble vehicles. We first use **"count()"** to automatically group all indentical **"Troubles"** descriptions and summarize their occurrences, sorting the results to put the most frequent one first. 

Finally, as the final step, we use **"head(5)"** to select and display only the five troubles with the highest counts.

```{r}
# Find the top 5 common troubles by aggregating 'Troubles' to find the most frequent descriptions.
top_troubles <- full_data %>%
  count(Troubles, sort = TRUE) %>% 
  # groups the data by every unique entry in the Troubles column
  # then counts how many times each unique trouble appears,
  # then sorts the results from highest to lowest.
  head(5) # selects and keeps only the top 5 rows from the sorted list

print("Top 5 Common Troubles are related to:")
print(top_troubles)
```

Here we can see the 5 most common troubles are:

1. Cylinders

2. Chassis

3. Ignition (finding)

4. Noise (finding)

5. Worn tires


## 3.5 Do the troubles differ between engine types?  

To explore whether certain problems are more common in specific engine types, a bar stacked chart would offer best as it would show both the total frequency of each trouble and how those issues are distributed across engine types.

In this visualiation, **"coord_flip()"** was applied to rotate the chart, making long trouble names easier to read and improving interpretability.

```{r, fig.width = 12, fig.height = 8, out.width = "80%"}
# A visualization of stacked bar chart to compare the count of troubles across Engine Types.
ggplot(full_data, aes(x = Troubles, fill = EngineType)) + 
  # sets 'Troubles' as category to be counted and 'EngineType' to fill (all using 'full_data')
  geom_bar(position = "stack") + # this creates a stack barchat
  coord_flip() + # rotates the chart, making long names easier to read
  labs(title = "Troubles Distribution by Engine Type", # title
       subtitle = "Count of troubles per engine type", # sub-title (to explain further)
       x = "Trouble Description", y = "Count") +  # x and y axis
  theme_minimal() # removes the default gray background
```

From the chart above, we can see that some trouble types are strongly associated with particular engine types. For example, how 'ohc' engines appear to have the largest share of issues across many categories. 

Overall, with the purpose to compare between different engine types, it is best if we employ a visualisation to better spot the differences.

# Task 4:

## Pre-requisite fix

Before any analysis in Task 4, we explicitly assign **"trouble_data <- full_data"**. As previously, 'full_data' was used to filter the maintenance records and then joined. This step is to make sure that we can use a consistent set where only vehicles with confirmed or suspected faults. 

```{r}
# Previously we created "full_data" that filters out the "No error"
# Here, we would want to define the "trouble_data" to ensure the rest of the code runs smoothly.
trouble_data <- full_data
```

Doing this prevents accidental re-use of the full unfiltered maintenance table, clarifies intent to readers of the script, and makes the flow much smoother.

## 4.1 Most frequent error codes

Here, to find the most frequent code we use the frequency count, **"count(ErrorCodes, sort = TRUE)"** to aggregate and order ErrorCodes from most to least common (with most common at the top). Along with **"slice(1)"** function to isolate and pick the most frequent code away from the rest.

```{r}
# By grouping error codes and count them to identify the most relevant issue
frequent_error <- trouble_data %>%
  count(ErrorCodes, sort = TRUE) %>% # aggregates the data and sorts them from most to least common
  slice(1) # extracts the single most frequent code

print(paste("Most frequent error code:", frequent_error$ErrorCodes))
```
In our case, the most frequent error code is **'1'**. Practically, this means that among the vehicles flagged as having problems, the diagnostic labeled as 1 appears most frequently. 

Because we previously removed **'0'** entries, this is not a “no issue, it just genuinely identifies the single most common problem type that mechanics recorded ( "Error Code 1").
